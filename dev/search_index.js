var documenterSearchIndex = {"docs":
[{"location":"tensors/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"If you have reached here, you probably know what a tensor is, and probably have heard many jokes about what a tensor is[1]. Nevertheless, we are gonna give a brief remainder.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"[1]: For example, recursive definitions like a tensor is whatever that transforms as a tensor.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"A tensor T of order[2] n is a multilinear[3] function between n vector spaces over a field mathcalF.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"[2]: The order of a tensor may also be known as rank or dimensionality in other fields. However, these can be missleading, since it has nothing to do with the rank of linear algebra nor with the dimensionality of a vector space. Thus we prefer to use the word order.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"[3]: Meaning that the relationships between the output and the inputs, and the inputs between them, are linear.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"T  mathcalF^dim(1) times dots times mathcalF^dim(n) mapsto mathcalF","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"In layman's terms, you can view a tensor as a linear function that maps a set of vectors to a scalar.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"T(mathbfv^(1) dots mathbfv^(n)) = c in mathcalF qquadqquad forall i mathbfv^(i) in mathcalF^dim(i)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Just like with matrices and vectors, n-dimensional arrays of numbers can be used to represent tensors. Furthermore, scalars, vectors and matrices can be viewed as tensors of order 0, 1 and 2, respectively.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"The dimensions of the tensors are usually identified with labels and known as tensor indices or just indices. By appropeately fixing the indices in a expression, a lot of different linear algebra operations can be described.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"For example, the trace operation...","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"tr(A) = sum_i A_ii","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"... a tranposition of dimensions...","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"A_ji = A^T_ij","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"... or a matrix multiplication.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"C_ik = sum_j A_ij B_jk","category":"page"},{"location":"tensors/#The-Tensor-type","page":"Tensors","title":"The Tensor type","text":"","category":"section"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"In Muscle, a tensor is represented by the Tensor type, which wraps an array and a list of Index. An Index is wrapper type that can fit anything in it.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Index(:i)\nIndex(1)\nIndex((1,2))","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"You can create a Tensor by passing an AbstractArray and a Vector or Tuple of Indexs.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"t = Tensor(rand(3,5,2), [Index(:i), Index(:j), Index(:k)])","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"tip: Tip\nFor backward compatibility, if all the indices are Index{Symbol}s, you can directly pass a list of Symbols to the Tensor constructor. For example,Tensor(rand(3,2), [:i, :j])","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Use parent and inds to access the underlying array and indices respectively.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"parent(t)\ninds(t)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"The dimensionality or size of each index can be consulted using the size function.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"size(t)\nsize(t, Index(:j))\nlength(t)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Note that these indices are the ones that really define the dimensions of the tensor and not the order of the array dimensions.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"a = Tensor([1 0; 1 0], (:i, :j))\nb = Tensor([1 1; 0 0], (:j, :i))\na â‰ˆ b","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"This is key for interacting with other tensors.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"c = a + b\nparent(a) + parent(b)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"As such adjoint doesn't permute the dimensions; it just conjugates the array.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"d = Tensor([1im 2im; 3im 4im], (:i, :j))\nd'\nconj(d)","category":"page"},{"location":"tensors/#Indexing","page":"Tensors","title":"Indexing","text":"","category":"section"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Tensor, as a subtype of AbstractArray, allows direct indexing of the underneath array with getindex/setindex! or the [...] notation.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"a[1,1] = 3\na[1,:]","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"But like explained above, on Tensor you should refer the dimensions by their index label, which Tenet allows in many methods.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"a[i=1,j=1]","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Check out that not specifying all the indices is equivalent to using : on the non-specified indices.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"a[i=1]\na[i=1,j=:]","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Other supported methods are permutedims, selectdim and view.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"permutedims(a, [:j, :i])\nselectdim(a, :i, 1)\nview(a, :i=>1)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/#Muscle.Tensor","page":"API","title":"Muscle.Tensor","text":"Tensor{T,N,A<:AbstractArray{T,N}} <: AbstractArray{T,N}\n\nAn array-like object with named dimensions (i.e. Index).\n\n\n\n\n\n","category":"type"},{"location":"api/#Muscle.Tensor-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{A, NTuple{N, T} where T}} where {T, N, A<:AbstractArray{T, N}}","page":"API","title":"Muscle.Tensor","text":"Tensor(data::AbstractArray{T,N}, inds::AbstractVector{Index})\nTensor(data::AbstractArray{T,N}, inds::NTuple{N,Index}) where {T,N}\nTensor(data::AbstractArray{T,0}) where {T}\nTensor(data::Number)\n\nConstruct a tensor with the given data and indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.adjoint-Tuple{Tensor}","page":"API","title":"Base.adjoint","text":"Base.adjoint(::Tensor)\n\nReturn the adjoint of the tensor.\n\nnote: Note\nThis method doesn't transpose the array. It is equivalent to conj.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.cat-Tuple{Tensor, Tensor}","page":"API","title":"Base.cat","text":"Base.cat(a::Tensor, b::Tensor; dims)\n\nConcatenate two tensors a and b along the specified dimensions dims.\n\nThe indices of the tensors must be equal, otherwise the second tensor will be permuted to match the first one.\n\nnote: Note\ndims must be a list of Index.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.conj-Tuple{Tensor{var\"#s21\", 0, A} where {var\"#s21\"<:Complex, A<:AbstractArray{var\"#s21\", 0}}}","page":"API","title":"Base.conj","text":"Base.conj(::Tensor)\n\nReturn the conjugate of the tensor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.dropdims-Tuple{Tensor}","page":"API","title":"Base.dropdims","text":"Base.dropdims(tensor::Tensor; dims)\n\nReturn a tensor where the dimensions specified by dims are removed. size(tensor, dim) == 1 for each dimension in dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Tensor, Vararg{Any}}","page":"API","title":"Base.getindex","text":"Base.getindex(::Tensor, i...)\nBase.getindex(::Tensor; i...)\n(::Tensor)[index=i...]\n\nReturn the element of the tensor at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Tensor}","page":"API","title":"Base.length","text":"Base.length(::Tensor)\n\nReturn the length of the underlying array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parent-Tuple{Tensor}","page":"API","title":"Base.parent","text":"Base.parent(::Tensor)\n\nReturn the underlying array of the tensor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.permutedims-Tuple{Tensor, Any}","page":"API","title":"Base.permutedims","text":"Base.permutedims(tensor::Tensor, perm)\n\nPermute the dimensions of tensor according to the given permutation perm. The inds will be permuted accordingly.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace-Tuple{Tensor, Vararg{Pair}}","page":"API","title":"Base.replace","text":"Base.replace(::Tensor, old_new::Pair{Index,Index}...)\n\nReplace the indices of the tensor according to the given pairs of old and new indices.\n\nwarning: Warning\nThis method does not support cyclic replacements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.selectdim-Tuple{Tensor, Integer, Any}","page":"API","title":"Base.selectdim","text":"Base.selectdim(tensor::Tensor, dim::Index, i)\nBase.selectdim(tensor::Tensor, dim::Integer, i)\n\nReturn a view of the tensor where the index for dimension dim equals i.\n\nnote: Note\nThis method doesn't return a SubArray, but a Tensor wrapping a SubArray.\n\nSee also: selectdim\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Tensor, Any, Vararg{Any}}","page":"API","title":"Base.setindex!","text":"Base.setindex!(t::Tensor, v, i...)\nBase.setindex(::Tensor; i...)\n(::Tensor)[index=i...]\n\nSet the element of the tensor at the given indices to v.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.similar-Tuple{Tensor}","page":"API","title":"Base.similar","text":"Base.similar(::Tensor{T,N}[, S::Type, dims::Base.Dims{N}; inds])\n\nReturn a uninitialize tensor of the same size, eltype and inds as tensor. If S is provided, the eltype of the tensor will be S. If dims is provided, the size of the tensor will be dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{Tensor}","page":"API","title":"Base.size","text":"Base.size(::Tensor[, i::Index])\n\nReturn the size of the underlying array. If the dimension i (specified by Index or Integer) is specified, then the size of the corresponding dimension is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.view-Tuple{Tensor, Vararg{Any}}","page":"API","title":"Base.view","text":"Base.view(tensor::Tensor, i...)\nBase.view(tensor::Tensor, inds::Pair{<:Index,<:Any}...)\n\nReturn a view of the tensor with the given indices. If a Pair is given, the index is replaced by the value of the pair.\n\nnote: Note\nThis method doesn't return a SubArray, but a Tensor wrapping a SubArray.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.zero-Tuple{Tensor}","page":"API","title":"Base.zero","text":"Base.zero(tensor::Tensor)\n\nReturn a tensor of the same size, eltype and inds as tensor but filled with zeros.\n\n\n\n\n\n","category":"method"},{"location":"api/#EinExprs.inds-Tuple{Tensor}","page":"API","title":"EinExprs.inds","text":"inds(::Tensor)\n\nReturn the indices of the Tensor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muscle.binary_einsum","page":"API","title":"Muscle.binary_einsum","text":"binary_einsum(a::Tensor, b::Tensor; dims=âˆ©(inds(a), inds(b)), out=nothing)\n\nPerform a binary tensor contraction operation.\n\nKeyword arguments\n\n- `dims`: indices to contract over. Defaults to the set intersection of the indices of `a` and `b`.\n- `out`: indices of the output tensor. Defaults to the set difference of the indices of `a` and `b`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.binary_einsum!","page":"API","title":"Muscle.binary_einsum!","text":"binary_einsum!(c::Tensor, a::Tensor, b::Tensor)\n\nPerform a binary tensor contraction operation between a and b and store the result in c.\n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.dim-Tuple{Tensor, Number}","page":"API","title":"Muscle.dim","text":"dim(tensor::Tensor, i)\n\nReturn the location of the dimension of tensor corresponding to the given index i.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muscle.expand-Tuple{Tensor, Index, Any}","page":"API","title":"Muscle.expand","text":"expand(tensor::Tensor, ind::Index, size; method=:zeros)\n\nPad the tensor along the dimension specified by ind to reach new size. Supported methods are :zeros and :rand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muscle.extend-Tuple{Tensor}","page":"API","title":"Muscle.extend","text":"extend(tensor::Tensor; label[, axis=1, size=1, method=:zeros])\n\nExpand the tensor by adding a new dimension label with the given size at the specified axis. Currently the supported methods are :zeros and :repeat.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muscle.fuse-Tuple{Tensor, Any}","page":"API","title":"Muscle.fuse","text":"fuse(tensor, parinds; ind=first(parinds))\n\nFuses parinds, leaves them on the right-side internally permuted with permutator and names it as ind.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muscle.tensor_eigen_thin","page":"API","title":"Muscle.tensor_eigen_thin","text":"Muscle.tensor_eigen_thin(tensor::Tensor; inds_u, inds_uinv, ind_lambda, kwargs...)\n\nPerform eigen factorization on a tensor. Either inds_u or inds_uinv must be specified.\n\nKeyword arguments\n\ninds_u: left / U indices to be used in the eigen factorization, except for ind_lambda.\ninds_uinv: right / right indices to be used in the eigen factorization, except for ind_lambda.\nind_lambda: name of the virtual bond.\ninplace: If true, it will use A as workspace variable to save space. Defaults to false.\nkwargs...: additional keyword arguments to be passed to LinearAlgebra.eigen.\n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.tensor_qr_thin","page":"API","title":"Muscle.tensor_qr_thin","text":"tensor_qr_thin(tensor::Tensor; inds_q, inds_r, ind_virtual, kwargs...)\n\nPerform QR factorization on a tensor. Either inds_q or inds_r must be specified.\n\nKeyword arguments\n\ninds_q: left indices to be used in the QR factorization. Defaults to all indices of t except inds_r.\ninds_r: right indices to be used in the QR factorization. Defaults to all indices of t except inds_q.\nind_virtual: name of the virtual bond. Defaults to a random Index{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.tensor_svd_thin","page":"API","title":"Muscle.tensor_svd_thin","text":"Muscle.tensor_svd_thin(tensor::Tensor; inds_u, inds_v, ind_s, kwargs...)\n\nPerform SVD factorization on a tensor. Either inds_u or inds_v must be specified.\n\nKeyword arguments\n\ninds_u: left / U indices to be used in the SVD factorization, except for ind_s.\ninds_v: right / right indices to be used in the SVD factorization, except for ind_s.\nind_s: name of the virtual bond.\ninplace: If true, it will use A as workspace variable to save space. Defaults to false.\nkwargs...: additional keyword arguments to be passed to LinearAlgebra.svd.\n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.tensor_svd_trunc","page":"API","title":"Muscle.tensor_svd_trunc","text":"Muscle.tensor_svd_trunc(tensor::Tensor; inds_u, inds_v, ind_s, threshold, maxbondim, kwargs...)\n\nSame as tensorsvdthin() but with truncation, additional keyword arguments are\n\nthreshold: relative cutoff for singular values\nmaxdim: maximum bond dimension \n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.tensor_svd_trunc-Tuple{Muscle.BackendBase, Tensor}","page":"API","title":"Muscle.tensor_svd_trunc","text":"Truncate SVD. With these defaults, it could be used as inplace replacement for tensorsvdthin\n\n\n\n\n\n","category":"method"},{"location":"api/#Muscle.unary_einsum","page":"API","title":"Muscle.unary_einsum","text":"unary_einsum(a::Tensor; dims=âˆ©(inds(a), inds(b)), out=nothing)\n\nPerform a unary tensor contraction operation.\n\nKeyword arguments\n\n- `dims`: indices to contract over. Defaults to the repeated indices.\n- `out`: indices of the output tensor. Defaults to the unique indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Muscle.unary_einsum!","page":"API","title":"Muscle.unary_einsum!","text":"unary_einsum!(c::Tensor, a::Tensor)\n\nPerform a unary tensor contraction operation on a and store the result in c.\n\n\n\n\n\n","category":"function"},{"location":"operations/contraction/#Contraction","page":"Contraction","title":"Contraction","text":"","category":"section"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"Einsum operations are performed automatically by unary_einsum and binary_einsum.","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"Unlike other tensor libraries, the einsum pattern is not explicitly stated by the user but implicitly inferred from the Tensor objects; i.e. repeated indices will be contracted while unique indices will remain. However, the user might require some flexibility on the output and contracted indices. That's why unary_einsum and binary_einsum have two extra keyword arguments: dims, which lists the indices to be contracted, and out, which lists the resulting indices after the contraction. Keep in mind that you're not forced to define them: dims defaults to the repeated indices and out defaults to the unique indices, but it's not recommended to define both.","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"For example, let's imagine that we want to perform the following operation: A sum over one dimension of a tensor.","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"X_j = sum_i A_ij","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"unary_einsum can act on just one tensor (unary contraction) and the user can write the following operation in two different ways:","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"Muscle.unary_einsum(a; dims=[Index(:i)])\nMuscle.unary_einsum(a; out=[Index(:j)])","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"For the case of binary contraction, imagine the following matrix multiplication:","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"Y_j = sum_i A_ij B_ji","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"Then the default would be enough, although you can still define dims or out.","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"Muscle.binary_einsum(a, b)\nMuscle.binary_einsum(a, b; dims=[Index(:i)])\nMuscle.binary_einsum(a, b; out=[Index(:j)])","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"But what if instead of contracting index :i, we want to perform a Hadamard product (element-wise multiplication)? Then that's a case where implicit inference of the einsum rule is not enough and you need to specify dims or out.","category":"page"},{"location":"operations/contraction/","page":"Contraction","title":"Contraction","text":"# Muscle.binary_einsum(a, b; dims=Index[])\nMuscle.binary_einsum(a, b; out=[Index(:i), Index(:j)])","category":"page"},{"location":"operations/qr/#QR-decompostion","page":"QR","title":"QR decompostion","text":"","category":"section"},{"location":"operations/qr/","page":"QR","title":"QR","text":"t = Tensor(rand(2,2,2,2), [:i,:j,:k,:l]);\nq, r = tensor_qr_thin(\n    t;\n    inds_q = Index.([:i, :k]),\n    inds_r = Index.([:j, :l]),\n    ind_virtual = Index(:x)\n);\nq\nr","category":"page"},{"location":"operations/svd/#Singular-Value-Decomposition","page":"SVD","title":"Singular Value Decomposition","text":"","category":"section"},{"location":"operations/svd/","page":"SVD","title":"SVD","text":"t = Tensor(rand(2,2,2,2), [:i,:j,:k,:l]);\nu, s, v = tensor_svd_thin(\n    t;\n    inds_u = Index.([:i, :k]),\n    inds_v = Index.([:j, :l]),\n    ind_s = Index(:x)\n);\nu\ns\nv","category":"page"},{"location":"#Muscle.jl","page":"Home","title":"Muscle.jl","text":"","category":"section"}]
}
